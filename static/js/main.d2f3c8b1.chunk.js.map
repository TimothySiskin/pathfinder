{"version":3,"sources":["components/node.js","aStarAlgorithm/aStar.js","primsMazeAlgorithm/primsMaze.js","recursiveDivision/recursiveDivision.js","components/buttons.jsx","components/pathfind.js","App.js","index.js"],"names":["Node","isStart","isEnd","row","col","classes","isWall","weight","className","id","Astar","startNode","endNode","openSet","closeSet","path","visitedNodes","push","leastIndex","i","length","f","current","temp","previous","filter","element","neighbors","neighbor","includes","tempG","g","newPath","h","heruistic","a","b","Math","abs","x","y","error","primsMaze","walls","grid","end","maze","Set","cells","add","value","primsAlgorithm","size","neighborPath","values","has","randomCell","floor","random","randomWall","delete","buttons","props","visualizePath","visualizeMaze","setMaze","mazeGen","cleanVisualization","cleanMaze","e","preventDefault","type","target","onSubmit","name","selected","onClick","recursiveDivisionMaze","finishNode","vertical","range","horizontal","getRecursiveWalls","forEach","cell","wall","len","result","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","isStartFinish","tempWalls","splice","generateRandomNumber","cols","Pathfind","useState","Grid","setGrid","Path","setPath","VisitedNodes","setVisitedNodes","startAndEnd","setStartAndEnd","Maze","isInitialMount","useRef","useEffect","initializeGrid","func","start","pathFindAlg","Array","createSpot","addNeighbors","rows","j","Spot","addneighbors","this","undefined","gridWithNode","map","colsIndex","rowsIndex","document","getElementById","index","setTimeout","animate","visualizeShortesPath","node","shotestPathNodes","recursiveDivision","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.d2f3c8b1.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./node.css\";\r\n\r\nconst Node = ({ isStart, isEnd, row, col, isWall, weight }) => {\r\n  const classes = isStart ? \"node-start\" : isEnd ? \"node-end\" : \"\";\r\n  return (\r\n    <div className={`node ${classes}`} id={`node-${col}-${row}`}>\r\n      {\" \"}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Node;\r\n","function Astar(startNode, endNode) {\r\n  let openSet = [];\r\n  let closeSet = [];\r\n  let path = [];\r\n  let visitedNodes = [];\r\n  \r\n\r\n  openSet.push(startNode);\r\n\r\n  while (openSet.length > 0) {\r\n    let leastIndex = 0;\r\n    for (let i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[leastIndex].f) {\r\n        leastIndex = i;\r\n      }\r\n    }\r\n\r\n    let current = openSet[leastIndex];\r\n\r\n    visitedNodes.push(current);\r\n    if (current === endNode) {\r\n      let temp = current;\r\n      path.push(temp);\r\n\r\n      while (temp.previous) {\r\n        path.push(temp.previous);\r\n        temp = temp.previous;\r\n      }\r\n\r\n      return { path, visitedNodes };\r\n    }\r\n\r\n    openSet = openSet.filter((element) => element !== current);\r\n\r\n    closeSet.push(current);\r\n\r\n    let neighbors = current.neighbors;\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      let neighbor = neighbors[i];\r\n\r\n      if (!closeSet.includes(neighbor) && !neighbor.isWall) {\r\n        let tempG = current.g + 1;\r\n        let newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        if (newPath) {\r\n          neighbor.h = heruistic(neighbor, endNode);\r\n          neighbor.f = neighbor.h + neighbor.g;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function heruistic(a, b) {\r\n    let d = Math.abs(a.x - a.y) + Math.abs(b.x - b.y);\r\n    return d;\r\n  }\r\n\r\n  return { path, visitedNodes, error: \"No path found!\" };\r\n}\r\n\r\nexport default Astar;\r\n","function primsMaze(grid, startNode, endNode) {\r\n  let current = startNode;\r\n\r\n  let end = endNode;\r\n  let maze = new Set();\r\n  let walls = new Set();\r\n\r\n  //First step of algorithm: all cells must be walls\r\n\r\n  for (let cells of grid) {\r\n    for (let value of cells) {\r\n      value.isWall = true;\r\n    }\r\n  }\r\n\r\n  //secend step: chose a first cell and add it to the maze, next add neighbors to the walls:\r\n\r\n  current.isWall = false;\r\n  end.isWall = true;\r\n\r\n  maze.add(current);\r\n\r\n  for (let value of current.neighbors) {\r\n    walls.add(value);\r\n  }\r\n\r\n  primsAlgorithm(current);\r\n\r\n  //***************************************************************************************************** */\r\n\r\n  function primsAlgorithm(current) {\r\n    //third step:\r\n\r\n    if (walls.size > 0) {\r\n      //Cheking if only one cell neighbor is a path\r\n\r\n      let neighborPath = 0;\r\n\r\n      for (let value of current.neighbors) {\r\n        if (value.isWall === false) {\r\n          neighborPath++;\r\n        }\r\n      }\r\n\r\n      if (neighborPath === 1) {\r\n        current.isWall = false;\r\n        maze.add(current);\r\n        for (let values of current.neighbors) {\r\n          if (!maze.has(values)) {\r\n            walls.add(values);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    /*********************************************************************************************** */\r\n\r\n    let randomCell = Math.floor(Math.random() * walls.size);\r\n    let wallsArr = [...walls];\r\n    let randomWall = wallsArr[randomCell];\r\n\r\n    walls.delete(randomWall);\r\n\r\n    primsAlgorithm(randomWall);\r\n  }\r\n\r\n  end.isWall = false;\r\n  return maze;\r\n}\r\n\r\nexport default primsMaze;\r\n","let walls;\r\nexport default function recursiveDivisionMaze(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n  walls = [];\r\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\r\n  /******************************************************************* */\r\n  grid.forEach((cells) => {\r\n    cells.forEach((cell) => {\r\n      const { x, y } = cell;\r\n      walls.forEach((wall) => {\r\n        const [a, b] = wall;\r\n        if (x == a && y == b) {\r\n          cell.isWall = true;\r\n        }\r\n      });\r\n    });\r\n  });\r\n  /******************************************************************* */\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let dir;\r\n  let num;\r\n  if (vertical.length > horizontal.length) {\r\n    dir = 0;\r\n    num = generateOddRandomNumber(vertical);\r\n  }\r\n  if (vertical.length <= horizontal.length) {\r\n    dir = 1;\r\n    num = generateOddRandomNumber(horizontal);\r\n  }\r\n\r\n  if (dir === 0) {\r\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(\r\n      vertical.slice(0, vertical.indexOf(num)),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    getRecursiveWalls(\r\n      vertical.slice(vertical.indexOf(num) + 1),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  } else {\r\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(num)),\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    getRecursiveWalls(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(num) + 1),\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n  let max = array.length - 1;\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return array[randomNum];\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (temp === startNode.row && num === startNode.col) ||\r\n        (temp === finishNode.row && num === finishNode.col)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (num === startNode.row && temp === startNode.col) ||\r\n        (num === finishNode.row && temp === finishNode.col)\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}\r\n","import react from \"react\";\r\n\r\nconst buttons = (props) => {\r\n  const {\r\n    visualizePath,\r\n    visualizeMaze,\r\n    setMaze,\r\n    mazeGen,\r\n    cleanVisualization,\r\n    cleanMaze,\r\n  } = props;\r\n\r\n  async function submitHandler(e) {\r\n    e.preventDefault();\r\n    cleanVisualization();\r\n    setMaze({ type: e.target[0].value });\r\n    mazeGen(e.target[0].value);\r\n    visualizeMaze();\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <form onSubmit={submitHandler}>\r\n        <select name=\"maze-type\">\r\n          <option value=\"recursive\" selected>\r\n            Recursive Division Maze\r\n          </option>\r\n          <option value=\"primsMaze\">Prims Maze</option>\r\n          <option value=\"random\">Random Maze</option>\r\n        </select>\r\n        <button type=\"submit\">Create Maze</button>\r\n      </form>\r\n      <button onClick={visualizePath}>Visualize Path</button>\r\n      <button onClick={cleanMaze}>Clean Maze</button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default buttons;\r\n","import React, { useState, useEffect, useRef } from \"react\";\r\nimport Node from \"./node\";\r\nimport Astar from \"../aStarAlgorithm/aStar\";\r\nimport primsMaze from \"../primsMazeAlgorithm/primsMaze\";\r\nimport Buttons from \"./buttons\";\r\nimport \"./pathfind.css\";\r\nimport recursiveDivision from \"../recursiveDivision/recursiveDivision\";\r\n\r\n//DECLARING ROWS AND COLLUMNS FOR GRID\r\n\r\nconst rows = 25;\r\nconst cols = 41;\r\n\r\nconst NODE_START_ROW = 0;\r\nconst NODE_START_COL = 0;\r\n\r\nconst NODE_END_ROW = rows - 1;\r\nconst NODE_END_COL = cols - 1;\r\n\r\nconst Pathfind = () => {\r\n  const [Grid, setGrid] = useState([]);\r\n  const [Path, setPath] = useState([]);\r\n  const [VisitedNodes, setVisitedNodes] = useState([]);\r\n  const [startAndEnd, setStartAndEnd] = useState({});\r\n\r\n  const [Maze, setMaze] = useState({ type: \"empty\" });\r\n\r\n  const isInitialMount = useRef(true);\r\n\r\n  useEffect(() => {\r\n    initializeGrid();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (isInitialMount.current) {\r\n      isInitialMount.current = false;\r\n    } else {\r\n      pathFindAlg(Astar);\r\n    }\r\n  }, [Maze]);\r\n\r\n  //FUNCTION TO CREATE GRID\r\n  const initializeGrid = () => {\r\n    const grid = new Array(cols);\r\n\r\n    for (let i = 0; i < cols; i++) {\r\n      grid[i] = new Array(rows);\r\n    }\r\n\r\n    createSpot(grid);\r\n\r\n    setGrid(grid);\r\n\r\n    addNeighbors(grid);\r\n\r\n    setStartAndEnd({\r\n      start: grid[NODE_START_COL][NODE_START_ROW],\r\n      end: grid[NODE_END_COL][NODE_END_ROW],\r\n    });\r\n  };\r\n\r\n  //Function pathfinding alg\r\n\r\n  function pathFindAlg(func) {\r\n    let path = func(startAndEnd.start, startAndEnd.end);\r\n    setVisitedNodes(path.visitedNodes);\r\n    setPath(path.path);\r\n  }\r\n\r\n  function mazeGen(func) {\r\n    if (func === \"random\") {\r\n      Grid.forEach((cells) => {\r\n        cells.forEach((cell) => {\r\n          let random = Math.random();\r\n\r\n          if (random > 0.75) {\r\n            cell.isWall = true;\r\n          }\r\n        });\r\n      });\r\n    }\r\n    if (func === \"primsMaze\") {\r\n      primsMaze(Grid, startAndEnd.start, startAndEnd.end);\r\n    }\r\n    if (func === \"recursive\") {\r\n      recursiveDivision(Grid, startAndEnd.start, startAndEnd.end);\r\n    }\r\n  }\r\n\r\n  function cleanMaze() {\r\n    Grid.forEach((cells) => {\r\n      cells.forEach((cell) => {\r\n        cell.isWall = false;\r\n      });\r\n    });\r\n    cleanVisualization();\r\n  }\r\n  //CREATE THE SPOT\r\n\r\n  const createSpot = (grid) => {\r\n    for (let i = 0; i < cols; i++) {\r\n      for (let j = 0; j < rows; j++) {\r\n        grid[i][j] = new Spot(i, j);\r\n      }\r\n    }\r\n  };\r\n\r\n  //Add neighbors\r\n\r\n  const addNeighbors = (grid) => {\r\n    for (let i = 0; i < cols; i++) {\r\n      for (let j = 0; j < rows; j++) {\r\n        grid[i][j].addneighbors(grid);\r\n      }\r\n    }\r\n  };\r\n\r\n  //SPOT CONSTRUCTOR\r\n\r\n  function Spot(i, j) {\r\n    this.x = i;\r\n    this.y = j;\r\n    this.isStart = this.x === NODE_START_COL && this.y === NODE_START_ROW;\r\n    this.isEnd = this.x === NODE_END_COL && this.y === NODE_END_ROW;\r\n    this.g = 0;\r\n    this.f = 0;\r\n    this.h = 0;\r\n    this.neighbors = [];\r\n    this.isWall = false;\r\n    this.weight = 0;\r\n    this.previous = undefined;\r\n    this.addneighbors = function (grid) {\r\n      let i = this.x;\r\n      let j = this.y;\r\n      if (i > 0) this.neighbors.push(grid[i - 1][j]);\r\n      if (i < cols - 1) this.neighbors.push(grid[i + 1][j]);\r\n      if (j > 0) this.neighbors.push(grid[i][j - 1]);\r\n      if (j < rows - 1) this.neighbors.push(grid[i][j + 1]);\r\n    };\r\n  }\r\n\r\n  //GRID WITH NODE\r\n\r\n  const gridWithNode = (\r\n    <div className=\"container\">\r\n      {Grid.map((cols, colsIndex) => {\r\n        return (\r\n          <div key={colsIndex}>\r\n            {cols.map((rows, rowsIndex) => {\r\n              const { isStart, isEnd, isWall, weight } = rows;\r\n              return (\r\n                <Node\r\n                  key={rowsIndex}\r\n                  isStart={isStart}\r\n                  isEnd={isEnd}\r\n                  row={rowsIndex}\r\n                  col={colsIndex}\r\n                  isWall={isWall}\r\n                  weight={weight}\r\n                />\r\n              );\r\n            })}\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n\r\n  //Visualize Path\r\n\r\n  const visualizePath = () => {\r\n    animate();\r\n\r\n    function animate() {\r\n      for (let i = 0; i <= VisitedNodes.length; i++) {\r\n        if (i === VisitedNodes.length) {\r\n          setTimeout(() => {\r\n            visualizeShortesPath(Path);\r\n          }, 20 * i);\r\n        } else {\r\n          setTimeout(() => {\r\n            const node = VisitedNodes[i];\r\n            document.getElementById(`node-${node.x}-${node.y}`).className +=\r\n              \" node-visited\";\r\n          }, 20 * i);\r\n        }\r\n      }\r\n\r\n      const visualizeShortesPath = (shotestPathNodes) => {\r\n        for (let i = 0; i < shotestPathNodes.length; i++) {\r\n          setTimeout(() => {\r\n            const { x, y } = shotestPathNodes[i];\r\n            document.getElementById(`node-${x}-${y}`).className +=\r\n              \"node node-shortest-path\";\r\n          }, 10 * i);\r\n        }\r\n      };\r\n    }\r\n  };\r\n\r\n  /********************************************************************** */\r\n\r\n  const visualizeMaze = () => {\r\n    // toggle.current = true;\r\n    animate();\r\n\r\n    function animate() {\r\n      let index = 0;\r\n      for (let cells of Grid) {\r\n        for (let cell of cells) {\r\n          if (cell.isWall) {\r\n            setTimeout(() => {\r\n              const { x, y } = cell;\r\n              document.getElementById(`node-${x}-${y}`).className += \" isWall\";\r\n            }, 5 * index);\r\n          }\r\n          index++;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //******************************************************************************************* */\r\n\r\n  function cleanVisualization() {\r\n    Grid.forEach((cells) => {\r\n      cells.forEach((cell) => {\r\n        const { x, y } = cell;\r\n        cell.isWall = false;\r\n\r\n        document.getElementById(`node-${x}-${y}`).className = \"node\";\r\n\r\n        if (cell.isStart) {\r\n          document.getElementById(`node-${x}-${y}`).className =\r\n            \"node node-start\";\r\n        }\r\n        if (cell.isEnd) {\r\n          document.getElementById(`node-${x}-${y}`).className = \"node node-end\";\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  //RENDERING PATHFIND COMPONENT\r\n\r\n  return (\r\n    <div>\r\n      <h1>PathFind Component!</h1>\r\n\r\n      <Buttons\r\n        visualizeMaze={visualizeMaze}\r\n        visualizePath={visualizePath}\r\n        Maze={Maze}\r\n        setMaze={setMaze}\r\n        cleanVisualization={cleanVisualization}\r\n        mazeGen={mazeGen}\r\n        cleanMaze={cleanMaze}\r\n      />\r\n\r\n      <div>{gridWithNode}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Pathfind;\r\n","import React from 'react'\r\nimport './App.css';\r\n\r\nimport Pathfind from './components/pathfind'\r\n\r\nconst App = () => {\r\n  return (\r\n    <div className=\"App\">\r\n      <Pathfind />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}